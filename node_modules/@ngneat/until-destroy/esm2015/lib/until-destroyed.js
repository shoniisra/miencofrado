import { takeUntil } from 'rxjs/operators';
import { getSymbol, isFunction, createSubjectOnTheInstance, completeSubjectOnTheInstance, ensureClassIsDecorated } from './internals';
function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (isFunction(originalDestroy) === false) {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
export function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        return source.pipe(takeUntil(instance[symbol]));
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveWVkLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5nbmVhdC91bnRpbC1kZXN0cm95LyIsInNvdXJjZXMiOlsibGliL3VudGlsLWRlc3Ryb3llZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsMEJBQTBCLEVBQzFCLDRCQUE0QixFQUM1QixzQkFBc0IsRUFDdkIsTUFBTSxhQUFhLENBQUM7QUFFckIsU0FBUyxrQ0FBa0MsQ0FDekMsUUFBYSxFQUNiLGlCQUF5QixFQUN6QixNQUFjO0lBRWQsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFcEQsSUFBSSxVQUFVLENBQUMsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQ2IsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksa0RBQWtELGlCQUFpQixFQUFFLENBQ2xHLENBQUM7S0FDSDtJQUVELDBCQUEwQixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUU3QyxRQUFRLENBQUMsaUJBQWlCLENBQUMsR0FBRztRQUM1QixVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDdEUsNEJBQTRCLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzNDLGlFQUFpRTtRQUNqRSxtRUFBbUU7UUFDbkUsMkRBQTJEO1FBQzNELHdDQUF3QztRQUN4QyxRQUFRLENBQUMsaUJBQWlCLENBQUMsR0FBRyxlQUFlLENBQUM7SUFDaEQsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUksUUFBVyxFQUFFLGlCQUEyQjtJQUN4RSxPQUFPLENBQUksTUFBcUIsRUFBRSxFQUFFO1FBQ2xDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBSSxpQkFBaUIsQ0FBQyxDQUFDO1FBRS9DLDhEQUE4RDtRQUM5RCw4REFBOEQ7UUFDOUQsSUFBSSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsRUFBRTtZQUN6QyxrQ0FBa0MsQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDekU7YUFBTTtZQUNMLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pDLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUM5QztRQUVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUssUUFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgZ2V0U3ltYm9sLFxuICBpc0Z1bmN0aW9uLFxuICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbiAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbiAgZW5zdXJlQ2xhc3NJc0RlY29yYXRlZFxufSBmcm9tICcuL2ludGVybmFscyc7XG5cbmZ1bmN0aW9uIG92ZXJyaWRlTm9uRGlyZWN0aXZlSW5zdGFuY2VNZXRob2QoXG4gIGluc3RhbmNlOiBhbnksXG4gIGRlc3Ryb3lNZXRob2ROYW1lOiBzdHJpbmcsXG4gIHN5bWJvbDogc3ltYm9sXG4pOiB2b2lkIHtcbiAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKG9yaWdpbmFsRGVzdHJveSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0gaXMgdXNpbmcgdW50aWxEZXN0cm95ZWQgYnV0IGRvZXNuJ3QgaW1wbGVtZW50ICR7ZGVzdHJveU1ldGhvZE5hbWV9YFxuICAgICk7XG4gIH1cblxuICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZShpbnN0YW5jZSwgc3ltYm9sKTtcblxuICBpbnN0YW5jZVtkZXN0cm95TWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICBpc0Z1bmN0aW9uKG9yaWdpbmFsRGVzdHJveSkgJiYgb3JpZ2luYWxEZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSh0aGlzLCBzeW1ib2wpO1xuICAgIC8vIFdlIGhhdmUgdG8gcmUtYXNzaWduIHRoaXMgcHJvcGVydHkgYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgLy8gSWYgdGhlIGB1bnRpbERlc3Ryb3llZGAgb3BlcmF0b3IgaXMgY2FsbGVkIGZvciB0aGUgc2FtZSBpbnN0YW5jZVxuICAgIC8vIG11bHRpcGxlIHRpbWVzLCB0aGVuIHdlIHdpbGwgYmUgYWJsZSB0byBnZXQgdGhlIG9yaWdpbmFsXG4gICAgLy8gbWV0aG9kIGFnYWluIGFuZCBub3QgdGhlIHBhdGNoZWQgb25lLlxuICAgIGluc3RhbmNlW2Rlc3Ryb3lNZXRob2ROYW1lXSA9IG9yaWdpbmFsRGVzdHJveTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudGlsRGVzdHJveWVkPFQ+KGluc3RhbmNlOiBULCBkZXN0cm95TWV0aG9kTmFtZT86IGtleW9mIFQpIHtcbiAgcmV0dXJuIDxVPihzb3VyY2U6IE9ic2VydmFibGU8VT4pID0+IHtcbiAgICBjb25zdCBzeW1ib2wgPSBnZXRTeW1ib2w8VD4oZGVzdHJveU1ldGhvZE5hbWUpO1xuXG4gICAgLy8gSWYgYGRlc3Ryb3lNZXRob2ROYW1lYCBpcyBwYXNzZWQgdGhlbiB0aGUgZGV2ZWxvcGVyIGFwcGxpZXNcbiAgICAvLyB0aGlzIG9wZXJhdG9yIHRvIHNvbWV0aGluZyBub24tcmVsYXRlZCB0byBBbmd1bGFyIERJIHN5c3RlbVxuICAgIGlmICh0eXBlb2YgZGVzdHJveU1ldGhvZE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvdmVycmlkZU5vbkRpcmVjdGl2ZUluc3RhbmNlTWV0aG9kKGluc3RhbmNlLCBkZXN0cm95TWV0aG9kTmFtZSwgc3ltYm9sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5zdXJlQ2xhc3NJc0RlY29yYXRlZChpbnN0YW5jZSk7XG4gICAgICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZShpbnN0YW5jZSwgc3ltYm9sKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUodGFrZVVudGlsPFU+KChpbnN0YW5jZSBhcyBhbnkpW3N5bWJvbF0pKTtcbiAgfTtcbn1cbiJdfQ==