#!/usr/bin/env node
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
var glob = require("glob");
var fs = require("fs");
var ts_morph_1 = require("ts-morph");
var hasUntilDestroy = /import\s*{\s*[^}]*untilDestroyed[^}]*}\s*from\s*(["'])ngx-take-until-destroy\1(?=[^]*untilDestroyed\(\w*\)[^]*)/;
var _a = require('minimist')(process.argv.slice(2)), _b = _a.base, base = _b === void 0 ? 'src/app' : _b, removeOnDestroy = _a.removeOnDestroy;
var project = new ts_morph_1.Project({
    useInMemoryFileSystem: true,
    manipulationSettings: {
        quoteKind: ts_morph_1.QuoteKind.Single
    }
});
glob(base + "/**/*.ts", {}, function (_, files) {
    files.forEach(function (path) {
        fs.readFile(path, 'utf8', function (_, text) {
            if (!hasUntilDestroy.test(text))
                return;
            var result = transformCode(text, path, removeOnDestroy);
            fs.writeFile(path, result, 'utf8', function (err) {
                console.log(err || "Replaced " + path);
            });
        });
    });
});
function transformCode(code, filePath, removeOnDestroy) {
    if (removeOnDestroy === void 0) { removeOnDestroy = false; }
    var sourceFile = project.createSourceFile(filePath, code, { overwrite: true });
    replaceOldImport(sourceFile);
    sourceFile.getClasses().forEach(function (classDeclaration) {
        addUntilDestroyDecorator(classDeclaration);
        if (removeOnDestroy) {
            var ngOnDestroyDeclaration = classDeclaration.getMember('ngOnDestroy');
            if (!ngOnDestroyDeclaration)
                return;
            var ngOnDestroyIsNotEmpty = Boolean(ngOnDestroyDeclaration.getDescendantStatements().length);
            if (ngOnDestroyIsNotEmpty)
                return;
            ngOnDestroyDeclaration.remove();
            removeOnDestroyImplements(classDeclaration);
            removeOnDestroyImport(sourceFile);
        }
    });
    return sourceFile.getFullText();
}
exports.transformCode = transformCode;
function replaceOldImport(sourceFile) {
    var oldImport = sourceFile.getImportDeclaration('ngx-take-until-destroy');
    oldImport &&
        oldImport.replaceWithText("import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';");
}
function addUntilDestroyDecorator(classDeclaration) {
    var decorators = __spreadArrays([
        { name: 'UntilDestroy', arguments: [] }
    ], (classDeclaration.getStructure().decorators || []));
    classDeclaration.getDecorators().forEach(function (d) { return d.remove(); });
    classDeclaration.addDecorators(decorators);
}
function removeOnDestroyImplements(classDeclaration) {
    var onDestroyImplementClause = classDeclaration
        .getImplements()
        .find(function (impl) { return impl.getText() === 'OnDestroy'; });
    onDestroyImplementClause && classDeclaration.removeImplements(onDestroyImplementClause);
}
function removeOnDestroyImport(sourceFile) {
    var importDeclaration = sourceFile.getImportDeclaration('@angular/core');
    if (!importDeclaration)
        return;
    var importClause = importDeclaration.getImportClause();
    if (!importClause)
        return;
    var onDestroyImportSpecifier = importClause
        .getNamedImports()
        .find(function (node) { return node.getText() === 'OnDestroy'; });
    if (!onDestroyImportSpecifier)
        return;
    onDestroyImportSpecifier.remove();
    /* The existence of importClause is checked twice because importDeclaration mutates after OnDestroy is removed. */
    if (!importDeclaration.getImportClause()) {
        importDeclaration.remove();
    }
}
