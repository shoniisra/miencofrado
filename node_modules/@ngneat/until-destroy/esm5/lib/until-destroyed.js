import { takeUntil } from 'rxjs/operators';
import { getSymbol, isFunction, createSubjectOnTheInstance, completeSubjectOnTheInstance, ensureClassIsDecorated } from './internals';
function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    var originalDestroy = instance[destroyMethodName];
    if (isFunction(originalDestroy) === false) {
        throw new Error(instance.constructor.name + " is using untilDestroyed but doesn't implement " + destroyMethodName);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
export function untilDestroyed(instance, destroyMethodName) {
    return function (source) {
        var symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        return source.pipe(takeUntil(instance[symbol]));
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveWVkLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5nbmVhdC91bnRpbC1kZXN0cm95LyIsInNvdXJjZXMiOlsibGliL3VudGlsLWRlc3Ryb3llZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsMEJBQTBCLEVBQzFCLDRCQUE0QixFQUM1QixzQkFBc0IsRUFDdkIsTUFBTSxhQUFhLENBQUM7QUFFckIsU0FBUyxrQ0FBa0MsQ0FDekMsUUFBYSxFQUNiLGlCQUF5QixFQUN6QixNQUFjO0lBRWQsSUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFcEQsSUFBSSxVQUFVLENBQUMsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQ1YsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLHVEQUFrRCxpQkFBbUIsQ0FDbEcsQ0FBQztLQUNIO0lBRUQsMEJBQTBCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTdDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHO1FBQzVCLFVBQVUsQ0FBQyxlQUFlLENBQUMsSUFBSSxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztRQUN0RSw0QkFBNEIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDM0MsaUVBQWlFO1FBQ2pFLG1FQUFtRTtRQUNuRSwyREFBMkQ7UUFDM0Qsd0NBQXdDO1FBQ3hDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLGVBQWUsQ0FBQztJQUNoRCxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxVQUFVLGNBQWMsQ0FBSSxRQUFXLEVBQUUsaUJBQTJCO0lBQ3hFLE9BQU8sVUFBSSxNQUFxQjtRQUM5QixJQUFNLE1BQU0sR0FBRyxTQUFTLENBQUksaUJBQWlCLENBQUMsQ0FBQztRQUUvQyw4REFBOEQ7UUFDOUQsOERBQThEO1FBQzlELElBQUksT0FBTyxpQkFBaUIsS0FBSyxRQUFRLEVBQUU7WUFDekMsa0NBQWtDLENBQUMsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pFO2FBQU07WUFDTCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQywwQkFBMEIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDOUM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFLLFFBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gIGdldFN5bWJvbCxcbiAgaXNGdW5jdGlvbixcbiAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UsXG4gIGNvbXBsZXRlU3ViamVjdE9uVGhlSW5zdGFuY2UsXG4gIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWRcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG5mdW5jdGlvbiBvdmVycmlkZU5vbkRpcmVjdGl2ZUluc3RhbmNlTWV0aG9kKFxuICBpbnN0YW5jZTogYW55LFxuICBkZXN0cm95TWV0aG9kTmFtZTogc3RyaW5nLFxuICBzeW1ib2w6IHN5bWJvbFxuKTogdm9pZCB7XG4gIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlW2Rlc3Ryb3lNZXRob2ROYW1lXTtcblxuICBpZiAoaXNGdW5jdGlvbihvcmlnaW5hbERlc3Ryb3kpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9IGlzIHVzaW5nIHVudGlsRGVzdHJveWVkIGJ1dCBkb2Vzbid0IGltcGxlbWVudCAke2Rlc3Ryb3lNZXRob2ROYW1lfWBcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG5cbiAgaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgaXNGdW5jdGlvbihvcmlnaW5hbERlc3Ryb3kpICYmIG9yaWdpbmFsRGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNvbXBsZXRlU3ViamVjdE9uVGhlSW5zdGFuY2UodGhpcywgc3ltYm9sKTtcbiAgICAvLyBXZSBoYXZlIHRvIHJlLWFzc2lnbiB0aGlzIHByb3BlcnR5IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgIC8vIElmIHRoZSBgdW50aWxEZXN0cm95ZWRgIG9wZXJhdG9yIGlzIGNhbGxlZCBmb3IgdGhlIHNhbWUgaW5zdGFuY2VcbiAgICAvLyBtdWx0aXBsZSB0aW1lcywgdGhlbiB3ZSB3aWxsIGJlIGFibGUgdG8gZ2V0IHRoZSBvcmlnaW5hbFxuICAgIC8vIG1ldGhvZCBhZ2FpbiBhbmQgbm90IHRoZSBwYXRjaGVkIG9uZS5cbiAgICBpbnN0YW5jZVtkZXN0cm95TWV0aG9kTmFtZV0gPSBvcmlnaW5hbERlc3Ryb3k7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRpbERlc3Ryb3llZDxUPihpbnN0YW5jZTogVCwgZGVzdHJveU1ldGhvZE5hbWU/OiBrZXlvZiBUKSB7XG4gIHJldHVybiA8VT4oc291cmNlOiBPYnNlcnZhYmxlPFU+KSA9PiB7XG4gICAgY29uc3Qgc3ltYm9sID0gZ2V0U3ltYm9sPFQ+KGRlc3Ryb3lNZXRob2ROYW1lKTtcblxuICAgIC8vIElmIGBkZXN0cm95TWV0aG9kTmFtZWAgaXMgcGFzc2VkIHRoZW4gdGhlIGRldmVsb3BlciBhcHBsaWVzXG4gICAgLy8gdGhpcyBvcGVyYXRvciB0byBzb21ldGhpbmcgbm9uLXJlbGF0ZWQgdG8gQW5ndWxhciBESSBzeXN0ZW1cbiAgICBpZiAodHlwZW9mIGRlc3Ryb3lNZXRob2ROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgb3ZlcnJpZGVOb25EaXJlY3RpdmVJbnN0YW5jZU1ldGhvZChpbnN0YW5jZSwgZGVzdHJveU1ldGhvZE5hbWUsIHN5bWJvbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWQoaW5zdGFuY2UpO1xuICAgICAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKHRha2VVbnRpbDxVPigoaW5zdGFuY2UgYXMgYW55KVtzeW1ib2xdKSk7XG4gIH07XG59XG4iXX0=