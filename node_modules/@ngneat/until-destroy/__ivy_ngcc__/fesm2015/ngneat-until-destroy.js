import { Subject } from 'rxjs';
import { ɵNG_DIR_DEF, ɵNG_COMP_DEF, ɵNG_PIPE_DEF, ɵNG_PROV_DEF } from '@angular/core';
import { takeUntil } from 'rxjs/operators';

// This is done for type-safety and to make compiler happy
// because definition property names are exported as `string`,
// thus it throws `ɵNG_COMP_DEF can't be used to index type 'ɵComponentType<T>'.`
const NG_DIR_DEF = ɵNG_DIR_DEF;
const NG_COMP_DEF = ɵNG_COMP_DEF;
const NG_PIPE_DEF = ɵNG_PIPE_DEF;
// As directive and component definitions are considered private API,
// so those properties are prefixed with Angular's marker for "private".
function getDef(type) {
    return (type[NG_PIPE_DEF] ||
        type[NG_COMP_DEF] ||
        type[NG_DIR_DEF]);
}
function getDefName(type) {
    if (type.hasOwnProperty(NG_PIPE_DEF)) {
        return NG_PIPE_DEF;
    }
    else if (type.hasOwnProperty(NG_COMP_DEF)) {
        return NG_COMP_DEF;
    }
    else {
        return NG_DIR_DEF;
    }
}
// Determines whether the provided `target` is some function
// decorated with `@Injectable()`.
function isInjectableType(target) {
    return !!target[ɵNG_PROV_DEF];
}

function isFunction(target) {
    return typeof target === 'function';
}
/**
 * Applied to instances and stores `Subject` instance when
 * no custom destroy method is provided.
 */
const DESTROY = Symbol('__destroy');
/**
 * Applied to definitions and informs that class is decorated
 */
const DECORATOR_APPLIED = Symbol('__decoratorApplied');
/**
 * If we use the `untilDestroyed` operator multiple times inside the single
 * instance providing different `destroyMethodName`, then all streams will
 * subscribe to the single subject. If any method is invoked, the subject will
 * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
 * thus we store subjects under different symbols.
 */
function getSymbol(destroyMethodName) {
    if (typeof destroyMethodName === 'string') {
        return Symbol(`__destroy__${destroyMethodName}`);
    }
    else {
        return DESTROY;
    }
}
function missingDecorator(providerOrDef) {
    return !providerOrDef[DECORATOR_APPLIED];
}
function markAsDecorated(providerOrDef) {
    providerOrDef[DECORATOR_APPLIED] = true;
}
function ensureClassIsDecorated(instance) {
    const constructor = instance.constructor;
    const providerOrDef = isInjectableType(constructor) ? constructor : getDef(constructor);
    if (missingDecorator(providerOrDef)) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}
function createSubjectOnTheInstance(instance, symbol) {
    if (!instance[symbol]) {
        instance[symbol] = new Subject();
    }
}
function completeSubjectOnTheInstance(instance, symbol) {
    if (instance[symbol]) {
        instance[symbol].next();
        instance[symbol].complete();
        // We also have to re-assign this property thus in the future
        // we will be able to create new subject on the same instance.
        instance[symbol] = null;
    }
}

function unsubscribe(property) {
    property && isFunction(property.unsubscribe) && property.unsubscribe();
}
function unsubscribeIfPropertyIsArrayLike(property) {
    Array.isArray(property) && property.forEach(unsubscribe);
}
function decorateNgOnDestroy(ngOnDestroy, { arrayName, checkProperties, blackList }) {
    return function () {
        // Invoke the original `ngOnDestroy` if it exists
        ngOnDestroy && ngOnDestroy.call(this);
        // It's important to use `this` instead of caching instance
        // that may lead to memory leaks
        completeSubjectOnTheInstance(this, getSymbol());
        // Check if subscriptions are pushed to some array
        if (arrayName) {
            return unsubscribeIfPropertyIsArrayLike(this[arrayName]);
        }
        // Loop through the properties and find subscriptions
        if (checkProperties) {
            for (const property in this) {
                if (blackList && blackList.includes(property)) {
                    continue;
                }
                unsubscribe(this[property]);
            }
        }
    };
}
/**
 * Services do not have definitions, thus we just have to override the
 * prototype property in Ivy
 */
function decorateProvider(type, options) {
    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
    markAsDecorated(type);
}
/**
 * https://github.com/ngneat/until-destroy/issues/78
 * Some declared components or directives may be compiled asynchronously in JIT,
 * especially those that're lazy-loaded. And thus may have their
 * definition not accessible yet.
 */
function decorateDeclarableJIT(type, options) {
    const defName = getDefName(type);
    const getter = Object.getOwnPropertyDescriptor(type, defName).get;
    Object.defineProperty(type, defName, {
        get() {
            const def = getter();
            if (missingDecorator(def)) {
                def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
                markAsDecorated(def);
            }
            return def;
        }
    });
}
function decorateDeclarable(type, options) {
    const isJIT = type.hasOwnProperty('__annotations__');
    if (isJIT) {
        decorateDeclarableJIT(type, options);
    }
    else {
        const def = getDef(type);
        def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
        markAsDecorated(def);
    }
}
function UntilDestroy(options = {}) {
    return (target) => {
        if (isInjectableType(target)) {
            decorateProvider(target, options);
        }
        else {
            decorateDeclarable(target, options);
        }
    };
}

function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (isFunction(originalDestroy) === false) {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        return source.pipe(takeUntil(instance[symbol]));
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { UntilDestroy, untilDestroyed };

//# sourceMappingURL=ngneat-until-destroy.js.map