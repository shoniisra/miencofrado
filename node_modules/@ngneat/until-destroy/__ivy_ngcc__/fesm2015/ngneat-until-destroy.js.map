{"version":3,"file":"ngneat-until-destroy.js","sources":["ng:/@ngneat/until-destroy/lib/ivy.ts","ng:/@ngneat/until-destroy/lib/internals.ts","ng:/@ngneat/until-destroy/lib/until-destroy.ts","ng:/@ngneat/until-destroy/lib/until-destroyed.ts","ng:/@ngneat/until-destroy/ngneat-until-destroy.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Type,\n  InjectableType,\n  ɵNG_DIR_DEF,\n  ɵNG_COMP_DEF,\n  ɵNG_PIPE_DEF,\n  ɵNG_PROV_DEF,\n  ɵComponentType as ComponentType,\n  ɵDirectiveType as DirectiveType,\n  ɵPipeDef as PipeDef,\n  ɵComponentDef as ComponentDef,\n  ɵDirectiveDef as DirectiveDef\n} from '@angular/core';\n\n// This is done for type-safety and to make compiler happy\n// because definition property names are exported as `string`,\n// thus it throws `ɵNG_COMP_DEF can't be used to index type 'ɵComponentType<T>'.`\nconst NG_DIR_DEF = ɵNG_DIR_DEF as 'ɵdir';\nconst NG_COMP_DEF = ɵNG_COMP_DEF as 'ɵcmp';\nconst NG_PIPE_DEF = ɵNG_PIPE_DEF as 'ɵpipe';\n\n// Angular doesn't expose publicly `PipeType` but it actually has it.\nexport interface PipeType<T> extends Type<T> {\n  ɵpipe: never;\n}\n\n// As directive and component definitions are considered private API,\n// so those properties are prefixed with Angular's marker for \"private\".\nexport function getDef<T>(\n  type: PipeType<T> | ComponentType<T> | DirectiveType<T>\n): PipeDef<T> | DirectiveDef<T> | ComponentDef<T> {\n  return (\n    (type as PipeType<T>)[NG_PIPE_DEF] ||\n    (type as ComponentType<T>)[NG_COMP_DEF] ||\n    (type as DirectiveType<T>)[NG_DIR_DEF]\n  );\n}\n\nexport function getDefName<T>(type: PipeType<T> | ComponentType<T> | DirectiveType<T>) {\n  if (type.hasOwnProperty(NG_PIPE_DEF)) {\n    return NG_PIPE_DEF;\n  } else if (type.hasOwnProperty(NG_COMP_DEF)) {\n    return NG_COMP_DEF;\n  } else {\n    return NG_DIR_DEF;\n  }\n}\n\n// Determines whether the provided `target` is some function\n// decorated with `@Injectable()`.\nexport function isInjectableType(target: any): target is InjectableType<never> {\n  return !!target[ɵNG_PROV_DEF];\n}\n","import {\n  InjectableType,\n  ɵPipeDef as PipeDef,\n  ɵComponentDef as ComponentDef,\n  ɵDirectiveDef as DirectiveDef\n} from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { getDef, isInjectableType } from './ivy';\n\nexport function isFunction(target: unknown) {\n  return typeof target === 'function';\n}\n\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY: unique symbol = Symbol('__destroy');\n\n/**\n * Applied to definitions and informs that class is decorated\n */\nconst DECORATOR_APPLIED: unique symbol = Symbol('__decoratorApplied');\n\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nexport function getSymbol<T>(destroyMethodName?: keyof T): symbol {\n  if (typeof destroyMethodName === 'string') {\n    return Symbol(`__destroy__${destroyMethodName}`);\n  } else {\n    return DESTROY;\n  }\n}\n\nexport function missingDecorator<T>(\n  providerOrDef: InjectableType<T> | PipeDef<T> | ComponentDef<T> | DirectiveDef<T>\n): boolean {\n  return !(providerOrDef as any)[DECORATOR_APPLIED];\n}\n\nexport function markAsDecorated<T>(\n  providerOrDef: InjectableType<T> | PipeDef<T> | ComponentDef<T> | DirectiveDef<T>\n): void {\n  (providerOrDef as any)[DECORATOR_APPLIED] = true;\n}\n\nexport interface UntilDestroyOptions {\n  blackList?: string[];\n  arrayName?: string;\n  checkProperties?: boolean;\n}\n\nexport function ensureClassIsDecorated(instance: any): never | void {\n  const constructor = instance.constructor;\n  const providerOrDef = isInjectableType(constructor) ? constructor : getDef(constructor);\n\n  if (missingDecorator(providerOrDef)) {\n    throw new Error(\n      'untilDestroyed operator cannot be used inside directives or ' +\n        'components or providers that are not decorated with UntilDestroy decorator'\n    );\n  }\n}\n\nexport function createSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (!instance[symbol]) {\n    instance[symbol] = new Subject<void>();\n  }\n}\n\nexport function completeSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (instance[symbol]) {\n    instance[symbol].next();\n    instance[symbol].complete();\n    // We also have to re-assign this property thus in the future\n    // we will be able to create new subject on the same instance.\n    instance[symbol] = null;\n  }\n}\n","import {\n  InjectableType,\n  ɵComponentType as ComponentType,\n  ɵDirectiveType as DirectiveType\n} from '@angular/core';\nimport { SubscriptionLike } from 'rxjs';\n\nimport {\n  getSymbol,\n  isFunction,\n  markAsDecorated,\n  missingDecorator,\n  UntilDestroyOptions,\n  completeSubjectOnTheInstance\n} from './internals';\nimport { PipeType, getDef, getDefName, isInjectableType } from './ivy';\n\nfunction unsubscribe(property: SubscriptionLike | undefined): void {\n  property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\n\nfunction unsubscribeIfPropertyIsArrayLike(property: any[]): void {\n  Array.isArray(property) && property.forEach(unsubscribe);\n}\n\nfunction decorateNgOnDestroy(\n  ngOnDestroy: (() => void) | null | undefined,\n  { arrayName, checkProperties, blackList }: UntilDestroyOptions\n) {\n  return function(this: any) {\n    // Invoke the original `ngOnDestroy` if it exists\n    ngOnDestroy && ngOnDestroy.call(this);\n\n    // It's important to use `this` instead of caching instance\n    // that may lead to memory leaks\n    completeSubjectOnTheInstance(this, getSymbol());\n\n    // Check if subscriptions are pushed to some array\n    if (arrayName) {\n      return unsubscribeIfPropertyIsArrayLike(this[arrayName]);\n    }\n\n    // Loop through the properties and find subscriptions\n    if (checkProperties) {\n      for (const property in this) {\n        if (blackList && blackList.includes(property)) {\n          continue;\n        }\n\n        unsubscribe(this[property]);\n      }\n    }\n  };\n}\n\n/**\n * Services do not have definitions, thus we just have to override the\n * prototype property in Ivy\n */\nfunction decorateProvider(type: InjectableType<unknown>, options: UntilDestroyOptions): void {\n  type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n  markAsDecorated(type);\n}\n\n/**\n * https://github.com/ngneat/until-destroy/issues/78\n * Some declared components or directives may be compiled asynchronously in JIT,\n * especially those that're lazy-loaded. And thus may have their\n * definition not accessible yet.\n */\nfunction decorateDeclarableJIT<T>(\n  type: PipeType<T> | ComponentType<T> | DirectiveType<T>,\n  options: UntilDestroyOptions\n) {\n  const defName = getDefName(type);\n  const getter = Object.getOwnPropertyDescriptor(type, defName)!.get!;\n\n  Object.defineProperty(type, defName, {\n    get() {\n      const def = getter();\n\n      if (missingDecorator(def)) {\n        (def as { onDestroy: () => void }).onDestroy = decorateNgOnDestroy(\n          def.onDestroy,\n          options\n        );\n        markAsDecorated(def);\n      }\n\n      return def;\n    }\n  });\n}\n\nfunction decorateDeclarable<T>(\n  type: PipeType<T> | ComponentType<T> | DirectiveType<T>,\n  options: UntilDestroyOptions\n) {\n  const isJIT = type.hasOwnProperty('__annotations__');\n\n  if (isJIT) {\n    decorateDeclarableJIT(type, options);\n  } else {\n    const def = getDef(type);\n    (def as { onDestroy: () => void }).onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n    markAsDecorated(def);\n  }\n}\n\nexport function UntilDestroy(options: UntilDestroyOptions = {}): ClassDecorator {\n  return (target: any) => {\n    if (isInjectableType(target)) {\n      decorateProvider(target, options);\n    } else {\n      decorateDeclarable(target, options);\n    }\n  };\n}\n","import { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport {\n  getSymbol,\n  isFunction,\n  createSubjectOnTheInstance,\n  completeSubjectOnTheInstance,\n  ensureClassIsDecorated\n} from './internals';\n\nfunction overrideNonDirectiveInstanceMethod(\n  instance: any,\n  destroyMethodName: string,\n  symbol: symbol\n): void {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (isFunction(originalDestroy) === false) {\n    throw new Error(\n      `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n\n  createSubjectOnTheInstance(instance, symbol);\n\n  instance[destroyMethodName] = function() {\n    isFunction(originalDestroy) && originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this, symbol);\n    // We have to re-assign this property back to the original value.\n    // If the `untilDestroyed` operator is called for the same instance\n    // multiple times, then we will be able to get the original\n    // method again and not the patched one.\n    instance[destroyMethodName] = originalDestroy;\n  };\n}\n\nexport function untilDestroyed<T>(instance: T, destroyMethodName?: keyof T) {\n  return <U>(source: Observable<U>) => {\n    const symbol = getSymbol<T>(destroyMethodName);\n\n    // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n    } else {\n      ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance, symbol);\n    }\n\n    return source.pipe(takeUntil<U>((instance as any)[symbol]));\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}