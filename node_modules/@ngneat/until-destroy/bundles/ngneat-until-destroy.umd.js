(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngneat/until-destroy', ['exports', 'rxjs', '@angular/core', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.ngneat = global.ngneat || {}, global.ngneat['until-destroy'] = {}), global.rxjs, global.ng.core, global.rxjs.operators));
}(this, (function (exports, rxjs, core, operators) { 'use strict';

    // This is done for type-safety and to make compiler happy
    // because definition property names are exported as `string`,
    // thus it throws `ɵNG_COMP_DEF can't be used to index type 'ɵComponentType<T>'.`
    var NG_DIR_DEF = core.ɵNG_DIR_DEF;
    var NG_COMP_DEF = core.ɵNG_COMP_DEF;
    var NG_PIPE_DEF = core.ɵNG_PIPE_DEF;
    // As directive and component definitions are considered private API,
    // so those properties are prefixed with Angular's marker for "private".
    function getDef(type) {
        return (type[NG_PIPE_DEF] ||
            type[NG_COMP_DEF] ||
            type[NG_DIR_DEF]);
    }
    function getDefName(type) {
        if (type.hasOwnProperty(NG_PIPE_DEF)) {
            return NG_PIPE_DEF;
        }
        else if (type.hasOwnProperty(NG_COMP_DEF)) {
            return NG_COMP_DEF;
        }
        else {
            return NG_DIR_DEF;
        }
    }
    // Determines whether the provided `target` is some function
    // decorated with `@Injectable()`.
    function isInjectableType(target) {
        return !!target[core.ɵNG_PROV_DEF];
    }

    function isFunction(target) {
        return typeof target === 'function';
    }
    /**
     * Applied to instances and stores `Subject` instance when
     * no custom destroy method is provided.
     */
    var DESTROY = Symbol('__destroy');
    /**
     * Applied to definitions and informs that class is decorated
     */
    var DECORATOR_APPLIED = Symbol('__decoratorApplied');
    /**
     * If we use the `untilDestroyed` operator multiple times inside the single
     * instance providing different `destroyMethodName`, then all streams will
     * subscribe to the single subject. If any method is invoked, the subject will
     * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
     * thus we store subjects under different symbols.
     */
    function getSymbol(destroyMethodName) {
        if (typeof destroyMethodName === 'string') {
            return Symbol("__destroy__" + destroyMethodName);
        }
        else {
            return DESTROY;
        }
    }
    function missingDecorator(providerOrDef) {
        return !providerOrDef[DECORATOR_APPLIED];
    }
    function markAsDecorated(providerOrDef) {
        providerOrDef[DECORATOR_APPLIED] = true;
    }
    function ensureClassIsDecorated(instance) {
        var constructor = instance.constructor;
        var providerOrDef = isInjectableType(constructor) ? constructor : getDef(constructor);
        if (missingDecorator(providerOrDef)) {
            throw new Error('untilDestroyed operator cannot be used inside directives or ' +
                'components or providers that are not decorated with UntilDestroy decorator');
        }
    }
    function createSubjectOnTheInstance(instance, symbol) {
        if (!instance[symbol]) {
            instance[symbol] = new rxjs.Subject();
        }
    }
    function completeSubjectOnTheInstance(instance, symbol) {
        if (instance[symbol]) {
            instance[symbol].next();
            instance[symbol].complete();
            // We also have to re-assign this property thus in the future
            // we will be able to create new subject on the same instance.
            instance[symbol] = null;
        }
    }

    function unsubscribe(property) {
        property && isFunction(property.unsubscribe) && property.unsubscribe();
    }
    function unsubscribeIfPropertyIsArrayLike(property) {
        Array.isArray(property) && property.forEach(unsubscribe);
    }
    function decorateNgOnDestroy(ngOnDestroy, _a) {
        var arrayName = _a.arrayName, checkProperties = _a.checkProperties, blackList = _a.blackList;
        return function () {
            // Invoke the original `ngOnDestroy` if it exists
            ngOnDestroy && ngOnDestroy.call(this);
            // It's important to use `this` instead of caching instance
            // that may lead to memory leaks
            completeSubjectOnTheInstance(this, getSymbol());
            // Check if subscriptions are pushed to some array
            if (arrayName) {
                return unsubscribeIfPropertyIsArrayLike(this[arrayName]);
            }
            // Loop through the properties and find subscriptions
            if (checkProperties) {
                for (var property in this) {
                    if (blackList && blackList.includes(property)) {
                        continue;
                    }
                    unsubscribe(this[property]);
                }
            }
        };
    }
    /**
     * Services do not have definitions, thus we just have to override the
     * prototype property in Ivy
     */
    function decorateProvider(type, options) {
        type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
        markAsDecorated(type);
    }
    /**
     * https://github.com/ngneat/until-destroy/issues/78
     * Some declared components or directives may be compiled asynchronously in JIT,
     * especially those that're lazy-loaded. And thus may have their
     * definition not accessible yet.
     */
    function decorateDeclarableJIT(type, options) {
        var defName = getDefName(type);
        var getter = Object.getOwnPropertyDescriptor(type, defName).get;
        Object.defineProperty(type, defName, {
            get: function () {
                var def = getter();
                if (missingDecorator(def)) {
                    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
                    markAsDecorated(def);
                }
                return def;
            }
        });
    }
    function decorateDeclarable(type, options) {
        var isJIT = type.hasOwnProperty('__annotations__');
        if (isJIT) {
            decorateDeclarableJIT(type, options);
        }
        else {
            var def = getDef(type);
            def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
            markAsDecorated(def);
        }
    }
    function UntilDestroy(options) {
        if (options === void 0) { options = {}; }
        return function (target) {
            if (isInjectableType(target)) {
                decorateProvider(target, options);
            }
            else {
                decorateDeclarable(target, options);
            }
        };
    }

    function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
        var originalDestroy = instance[destroyMethodName];
        if (isFunction(originalDestroy) === false) {
            throw new Error(instance.constructor.name + " is using untilDestroyed but doesn't implement " + destroyMethodName);
        }
        createSubjectOnTheInstance(instance, symbol);
        instance[destroyMethodName] = function () {
            isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
            completeSubjectOnTheInstance(this, symbol);
            // We have to re-assign this property back to the original value.
            // If the `untilDestroyed` operator is called for the same instance
            // multiple times, then we will be able to get the original
            // method again and not the patched one.
            instance[destroyMethodName] = originalDestroy;
        };
    }
    function untilDestroyed(instance, destroyMethodName) {
        return function (source) {
            var symbol = getSymbol(destroyMethodName);
            // If `destroyMethodName` is passed then the developer applies
            // this operator to something non-related to Angular DI system
            if (typeof destroyMethodName === 'string') {
                overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
            }
            else {
                ensureClassIsDecorated(instance);
                createSubjectOnTheInstance(instance, symbol);
            }
            return source.pipe(operators.takeUntil(instance[symbol]));
        };
    }

    exports.UntilDestroy = UntilDestroy;
    exports.untilDestroyed = untilDestroyed;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngneat-until-destroy.umd.js.map
